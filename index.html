<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Snake Game</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const rows = canvas.height / gridSize;
        const cols = canvas.width / gridSize;
        let snake = [{ x: 5, y: 5 }];
        let food = { x: 10, y: 10 };
        let direction = { x: 0, y: 0 };
        let gameInterval;

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'black';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    ctx.strokeRect(j * gridSize, i * gridSize, gridSize, gridSize);
                }
            }
        }

        function drawSnake() {
            ctx.fillStyle = 'green';
            snake.forEach(segment => {
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
            });
        }

        function drawFood() {
            ctx.fillStyle = 'red';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);
        }

        function moveSnake() {
            const newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
            if (newHead.x < 0 || newHead.x >= cols || newHead.y < 0 || newHead.y >= rows || snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
                clearInterval(gameInterval);
                alert('Game Over');
                return;
            }
            snake.unshift(newHead);
            if (newHead.x === food.x && newHead.y === food.y) {
                placeFood();
            } else {
                snake.pop();
            }
        }

        function placeFood() {
            let placed = false;
            while (!placed) {
                const x = Math.floor(Math.random() * cols);
                const y = Math.floor(Math.random() * rows);
                if (!snake.some(segment => segment.x === x && segment.y === y)) {
                    food = { x, y };
                    placed = true;
                }
            }
        }

        function changeDirection(event) {
            const keyPressed = event.keyCode;
            const goingUp = direction.y === -1;
            const goingDown = direction.y === 1;
            const goingRight = direction.x === 1;
            const goingLeft = direction.x === -1;
            if (keyPressed === 37 && !goingRight) { // left arrow
                direction = { x: -1, y: 0 };
            } else if (keyPressed === 38 && !goingDown) { // up arrow
                direction = { x: 0, y: -1 };
            } else if (keyPressed === 39 && !goingLeft) { // right arrow
                direction = { x: 1, y: 0 };
            } else if (keyPressed === 40 && !goingUp) { // down arrow
                direction = { x: 0, y: 1 };
            }
        }

        function autoMove() {
            const path = findPath();
            if (path.length > 0) {
                direction = { x: path[1].x - path[0].x, y: path[1].y - path[0].y };
            }
        }

        function findPath() {
            const queue = [snake[0]];
            const visited = new Set([`${snake[0].x},${snake[0].y}`]);
            const parentMap = new Map();
            parentMap.set(`${snake[0].x},${snake[0].y}`, null);
            while (queue.length > 0) {
                const current = queue.shift();
                if (current.x === food.x && current.y === food.y) {
                    return reconstructPath(parentMap, current);
                }
                const neighbors = getNeighbors(current);
                neighbors.forEach(neighbor => {
                    if (!visited.has(`${neighbor.x},${neighbor.y}`) && !snake.some(segment => segment.x === neighbor.x && segment.y === neighbor.y)) {
                        queue.push(neighbor);
                        visited.add(`${neighbor.x},${neighbor.y}`);
                        parentMap.set(`${neighbor.x},${neighbor.y}`, current);
                    }
                });
            }
            return [];
        }

        function getNeighbors(node) {
            const neighbors = [];
            if (node.x > 0) neighbors.push({ x: node.x - 1, y: node.y });
            if (node.x < cols - 1) neighbors.push({ x: node.x + 1, y: node.y });
            if (node.y > 0) neighbors.push({ x: node.x, y: node.y - 1 });
            if (node.y < rows - 1) neighbors.push({ x: node.x, y: node.y + 1 });
            return neighbors;
        }

        function reconstructPath(parentMap, endNode) {
            const path = [];
            let current = endNode;
            while (current !== null) {
                path.unshift(current);
                current = parentMap.get(`${current.x},${current.y}`);
            }
            return path;
        }

        function gameLoop() {
            drawGrid();
            drawSnake();
            drawFood();
            moveSnake();
        }

        function startGame() {
            gameInterval = setInterval(gameLoop, 100);
            document.addEventListener('keydown', changeDirection);
            setInterval(autoMove, 100); // Auto move every 500ms
        }

        placeFood();
        startGame();
    </script>
</body>
</html>
