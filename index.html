<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Snake Game</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 20;
    let snake = [{x: 160, y: 160}, {x: 140, y: 160}, {x: 120, y: 160}];
    let food = {x: 300, y: 300};
    let velocity = {x: gridSize, y: 0};
    let enemies = [];
    let bullets = [];
    let speedBoost = null;

    function drawSnakePart(snakePart) {
        ctx.fillStyle = 'lightgreen';
        ctx.strokeStyle = 'darkgreen';
        ctx.fillRect(snakePart.x, snakePart.y, gridSize, gridSize);
        ctx.strokeRect(snakePart.x, snakePart.y, gridSize, gridSize);
    }

    function drawSnake() {
        snake.forEach(drawSnakePart);
    }

    function moveSnake() {
        const head = {x: snake[0].x + velocity.x, y: snake[0].y + velocity.y};
        snake.unshift(head);
        const didEatFood = snake[0].x === food.x && snake[0].y === food.y;
        if (didEatFood) {
            createFood();
            if (speedBoost) {
                clearTimeout(speedBoost);
                speedBoost = setTimeout(resetSpeed, 5000);
            } else {
                speedBoost = setTimeout(resetSpeed, 5000);
            }
        } else {
            snake.pop();
        }
    }

    function changeDirection(event) {
        const keyPressed = event.keyCode;
        const goingUp = velocity.y === -gridSize;
        const goingDown = velocity.y === gridSize;
        const goingRight = velocity.x === gridSize;
        const goingLeft = velocity.x === -gridSize;

        if (keyPressed === 37 && !goingRight) { // left arrow
            velocity = {x: -gridSize, y: 0};
        }
        if (keyPressed === 38 && !goingDown) { // up arrow
            velocity = {x: 0, y: -gridSize};
        }
        if (keyPressed === 39 && !goingLeft) { // right arrow
            velocity = {x: gridSize, y: 0};
        }
        if (keyPressed === 40 && !goingUp) { // down arrow
            velocity = {x: 0, y: gridSize};
        }
    }

    function randomFood(min, max) {
        return Math.round((Math.random() * (max-min) + min) / gridSize) * gridSize;
    }

    function createFood() {
        food = {
            x: randomFood(0, canvas.width - gridSize),
            y: randomFood(0, canvas.height - gridSize)
        };
    }

    function drawFood() {
        ctx.fillStyle = 'red';
        ctx.fillRect(food.x, food.y, gridSize, gridSize);
    }

    function createEnemy() {
        enemies.push({
            x: randomFood(0, canvas.width - gridSize),
            y: randomFood(0, canvas.height - gridSize),
            direction: Math.floor(Math.random() * 4)
        });
    }

    function moveEnemies() {
        enemies.forEach(enemy => {
            switch (enemy.direction) {
                case 0: enemy.y -= gridSize; break; // up
                case 1: enemy.x += gridSize; break; // right
                case 2: enemy.y += gridSize; break; // down
                case 3: enemy.x -= gridSize; break; // left
            }
            if (enemy.x < 0 || enemy.x >= canvas.width || enemy.y < 0 || enemy.y >= canvas.height) {
                enemy.direction = Math.floor(Math.random() * 4); // Change direction when hitting the wall
            }
        });
    }

    function drawEnemies() {
        ctx.fillStyle = 'blue';
        enemies.forEach(enemy => {
            ctx.fillRect(enemy.x, enemy.y, gridSize, gridSize);
        });
    }

    function shootBullet() {
        bullets.push({x: snake[0].x, y: snake[0].y, direction: velocity});
    }

    function moveBullets() {
        bullets.forEach(bullet => {
            bullet.x += bullet.direction.x;
            bullet.y += bullet.direction.y;
        });
        bullets = bullets.filter(bullet => bullet.x >= 0 && bullet.x < canvas.width && bullet.y >= 0 && bullet.y < canvas.height);
    }

    function drawBullets() {
        ctx.fillStyle = 'black';
        bullets.forEach(bullet => {
            ctx.fillRect(bullet.x, bullet.y, gridSize, gridSize);
        });
    }

    function checkCollisions() {
        enemies.forEach((enemy, index) => {
            bullets.forEach((bullet, bulletIndex) => {
                if (bullet.x === enemy.x && bullet.y === enemy.y) {
                    enemies.splice(index, 1); // Remove enemy on hit
                    bullets.splice(bulletIndex, 1); // Remove bullet on hit
                }
            });
        });
    }

    function resetSpeed() {
        velocity = {x: gridSize, y: 0}; // Reset to default speed after boost ends
        speedBoost = null;
    }

    function clearCanvas() {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function gameLoop() {
        clearCanvas();
        drawFood();
        moveSnake();
        drawSnake();
        moveEnemies();
        drawEnemies();
        moveBullets();
        drawBullets();
        checkCollisions();
        setTimeout(gameLoop, 100);
    }

    document.addEventListener("keydown", changeDirection);
    document.addEventListener("keydown", (e) => { if (e.key === " ") shootBullet(); }); // Spacebar to shoot bullets
    setInterval(createEnemy, 2000); // Create an enemy every 2 seconds
    gameLoop();
</script>
</body>
</html>
