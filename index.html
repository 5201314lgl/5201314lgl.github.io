<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Snake Game</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const rows = canvas.height / gridSize;
        const cols = canvas.width / gridSize;
        let snake = [{ x: 5, y: 5 }];
        let food = { x: 10, y: 10 };
        let speedBoost = null;
        let enemies = [];
        let bullets = [];
        let direction = { x: 0, y: 0 };
        let gameInterval;
        let enemyInterval;
        let bulletInterval;

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'black';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    ctx.strokeRect(j * gridSize, i * gridSize, gridSize, gridSize);
                }
            }
        }

        function drawSnake() {
            ctx.fillStyle = 'green';
            snake.forEach(segment => {
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
            });
        }

        function drawFood() {
            ctx.fillStyle = 'red';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);
        }

        function drawSpeedBoost() {
            if (speedBoost) {
                ctx.fillStyle = 'blue';
                ctx.fillRect(speedBoost.x * gridSize, speedBoost.y * gridSize, gridSize, gridSize);
            }
        }

        function drawEnemies() {
            ctx.fillStyle = 'purple';
            enemies.forEach(enemy => {
                ctx.fillRect(enemy.x * gridSize, enemy.y * gridSize, gridSize, gridSize);
            });
        }

        function drawBullets() {
            ctx.fillStyle = 'yellow';
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x * gridSize, bullet.y * gridSize, gridSize, gridSize);
            });
        }

        function moveSnake() {
            const newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
            if (newHead.x < 0 || newHead.x >= cols || newHead.y < 0 || newHead.y >= rows || snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
                clearInterval(gameInterval);
                alert('Game Over');
                return;
            }
            snake.unshift(newHead);
            if (newHead.x === food.x && newHead.y === food.y) {
                placeFood();
            } else if (newHead.x === speedBoost?.x && newHead.y === speedBoost?.y) {
                speedBoost = null;
                clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, 50); // Speed up the game temporarily
                setTimeout(() => {
                    clearInterval(gameInterval);
                    gameInterval = setInterval(gameLoop, 100); // Restore normal speed after some time
                }, 5000); // Speed boost lasts for 5 seconds
            } else {
                snake.pop();
            }
        }

        function placeFood() {
            let placed = false;
            while (!placed) {
                const x = Math.floor(Math.random() * cols);
                const y = Math.floor(Math.random() * rows);
                if (!snake.some(segment => segment.x === x && segment.y === y)) {
                    food = { x, y };
                    placed = true;
                }
            }
        }

        function placeSpeedBoost() {
            let placed = false;
            while (!placed) {
                const x = Math.floor(Math.random() * cols);
                const y = Math.floor(Math.random() * rows);
                if (!snake.some(segment => segment.x === x && segment.y === y) && !food || (food.x !== x && food.y !== y)) {
                    speedBoost = { x, y };
                    placed = true;
                }
            }
        }

        function placeEnemies() {
            enemies = [];
            for (let i = 0; i < 3; i++) { // Place 3 enemies randomly
                let placed = false;
                while (!placed) {
                    const x = Math.floor(Math.random() * cols);
                    const y = Math.floor(Math.random() * rows);
                    if (!snake.some(segment => segment.x === x && segment.y === y) && !food || (food.x !== x && food.y !== y)) {
                        enemies.push({ x, y });
                        placed = true;
                    }
                }
            }
        }

        function moveEnemies() {
            enemies.forEach(enemy => {
                const directions = [{ x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }];
                const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                enemy.x += randomDirection.x;
                enemy.y += randomDirection.y;
                // Ensure enemies stay within bounds and don't overlap with each other or the snake
                if (enemy.x < 0) enemy.x = 0;
                if (enemy.x >= cols) enemy.x = cols - 1;
                if (enemy.y < 0) enemy.y = 0;
                if (enemy.y >= rows) enemy.y = rows - 1;
                if (snake.some(segment => segment.x === enemy.x && segment.y === enemy.y)) {
                    enemy.x -= randomDirection.x;
                    enemy.y -= randomDirection.y;
                }
            });
        }

        function shootBullet() {
            const bullet = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
            bullets.push(bullet);
        }

        function moveBullets() {
            bullets = bullets.map(bullet => ({ x: bullet.x + direction.x, y: bullet.y + direction.y }));
            bullets = bullets.filter(bullet => bullet.x >= 0 && bullet.x < cols && bullet.y >= 0 && bullet.y < rows);
        }

        function checkCollisions() {
            enemies = enemies.filter(enemy => !bullets.some(bullet => bullet.x === enemy.x && bullet.y === enemy.y));
        }

        function changeDirection(event) {
            const keyPressed = event.keyCode;
            const goingUp = direction.y === -1;
            const goingDown = direction.y === 1;
            const goingRight = direction.x === 1;
            const goingLeft = direction.x === -1;
            if (keyPressed === 37 && !goingRight) { // left arrow
                direction = { x: -1, y: 0 };
            } else if (keyPressed === 38 && !goingDown) { // up arrow
                direction = { x: 0, y: -1 };
            } else if (keyPressed === 39 && !goingLeft) { // right arrow
                direction = { x: 1, y: 0 };
            } else if (keyPressed === 40 && !goingUp) { // down arrow
                direction = { x: 0, y: 1 };
            } else if (keyPressed === 32) { // space bar to shoot bullets
                shootBullet();
            }
        }

        function autoMove() {
            const path = findPath();
            if (path.length > 0) {
                direction = { x: path[0].x - snake[0].x, y: path[0].y - snake[0].y };
            }
        }

        function findPath() {
            const queue = [snake[0]];
            const visited = new Set([`${snake[0].x},${snake[0].y}`]);
            const parentMap = new Map();
            parentMap.set(`${snake[0].x},${snake[0].y}`, null);
            while (queue.length > 0) {
                const current = queue.shift();
                if (current.x === food.x && current.y === food.y) {
                    return reconstructPath(parentMap, current);
                }
                const neighbors = getNeighbors(current);
                neighbors.forEach(neighbor => {
                    if (!visited.has(`${neighbor.x},${neighbor.y}`) && !snake.some(segment => segment.x === neighbor.x && segment.y === neighbor.y)) {
                        visited.add(`${neighbor.x},${neighbor.y}`);
                        queue.push(neighbor);
                        parentMap.set(`${neighbor.x},${neighbor.y}`, current);
                    }
                });
            }
            return [];
        }

        function getNeighbors(node) {
            const neighbors = [];
            if (node.x > 0) neighbors.push({ x: node.x - 1, y: node.y });
            if (node.x < cols - 1) neighbors.push({ x: node.x + 1, y: node.y });
            if (node.y > 0) neighbors.push({ x: node.x, y: node.y - 1 });
            if (node.y < rows - 1) neighbors.push({ x: node.x, y: node.y + 1 });
            return neighbors;
        }

        function reconstructPath(parentMap, endNode) {
            const path = [];
            let current = endNode;
            while (current !== null) {
                path.unshift(current);
                current = parentMap.get(`${current.x},${current.y}`);
            }
            return path;
        }

        function gameLoop() {
            drawGrid();
            drawSnake();
            drawFood();
            drawSpeedBoost();
            drawEnemies();
            drawBullets();
            moveSnake();
            moveEnemies();
            moveBullets();
            checkCollisions();
        }

        function startGame() {
            placeFood();
            placeSpeedBoost();
            placeEnemies();
            gameInterval = setInterval(gameLoop, 100); // Start the game loop at a regular interval of 100ms
            enemyInterval = setInterval(moveEnemies, 1000); // Move enemies every second
            bulletInterval = setInterval(moveBullets, 50); // Move bullets every 50ms
        }

        document.addEventListener('keydown', changeDirection); // Add keyboard listener for direction changes and shooting bullets
        startGame(); // Start the game when the page loads
    </script>
</body>
</html>
